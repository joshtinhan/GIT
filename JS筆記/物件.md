# 物件導向程式設計技術
1. 物件
- 物件會封裝屬性與方法，行為也可以是屬性。屬性的實質就是變數或常數，行為的實質就是方法（函數）。
2. 類別
- JS中萬物即物件，物件又會分門別類，底下的teacher就可以定義為一個類別，所有的teacher都有姓名、年齡等屬性，
只是屬性值可能不同。
3. 封裝
- 將屬性和行為綁定在一起，建立物件的過程。
4. 繼承
- 子類別可以繼承父類別的屬性和行為，同時也可以重新定義自己的屬性和行為。
5. 組合
- 一個類別可以作為另一個類別的屬性。例如引擎、輪胎等等小類別組成汽車的大類別。JS裡面沒有「類別」的結構，但是透過原型鏈，
可以很容易觀察到上面所提到的物件導向特性。
6. 多形
- 不同物件對同一訊息有不同的回應。舉例來說，上課鈴一響，教師都要進行教學動作，但是不同科目所教的內容一定不同。上課鈴聲可以視為訊息，讓教師執行教學動作，教學動作就是物件的回應，不同物件的回應各不相同。
# 在JS中實現繼承機制
1. 物件冒充 利用this特性
```JavaScript
    //建立People類別作為父類別
    function People(name,age){
        this.name = name;
        this.age = age;
    }
    function Teacher(name,age,subject){
        //轉換this的指向
        this.init = People;
        this.init(name,age);
        delete this.init;
        //增加教師類別特有的屬性
        this.subject = subject;
        this.teaching = function(){
            console.log("教師"+this.name+"正在教授"+this.subject+"課程。");
        }
    }
    var jake = new Teacher("Jake",25,"JavaScript");
    var lucy = new Teacher("Lucy",24,"Swift");
    jake.teaching(); //教師Jake正在教授JavaScript課程。
    lucy.teaching(); //教師Lucy正在教授Swift課程。
```
- 簡化版 用call()
```JavaScript
    function People(name,age){
        this.name = name;
        this.age = age;
    }
    function Teacher(name,age,subject){
        People.call(this,name,age);
        this.subject = subject;
        this.teaching = function(){
            console.log("教師"+this.name+"正在教授"+this.subject+"課程。");
        }
    }
    var jake = new Teacher("Jake",25,"JavaScript");
    var lucy = new Teacher("Lucy",24,"Swift");
    jake.teaching(); //教師Jake正在教授JavaScript課程。
    lucy.teaching(); //教師Lucy正在教授Swift課程。 
```
- 多重繼承
```JavaScript
    function People(name,age){
        this.name = name;
        this.age = age;
    }
    function Work(time){
        this.time = time;
    }
    function Teacher(name,age,subject){
        People.call(this,name,age);
        Work.call(this,8);
        this.subject = subject;
        this.teaching = function(){
            console.log("教師"+this.name+"正在教授"+this.subject+"課程。"+"工作時間："+this.time+"小時。")
        };
    }
    var jake = new Teacher("Jake",25,"JavaScript");
    var lucy = new Teacher("Lucy",24,"Swift");
    jake.teaching(); //教師Jake正在教授JavaScript課程。工作時間:8小時。
    lucy.teaching(); //教師Lucy正在教授Swift課程。工作時間:8小時。
```
2. 原型鏈方式實現繼承
在JS中，「除了原始值，萬物皆物件」，在建立函數時，除了函數物件本身，還會建立一個物件作為此函數物件的prototype屬性，例如
```JavaScript
    function People(){
        this.sayHi = function(){
            console.log("Hello, I am"+this.name+","+this.age+"years old ")
        }
    }
    console.log(People.prototype); //People {}
    function Teacher(name,age,subject){
        this.name = name;
        this.subject = subject;
        this.age = age;
    }
    //設定prototype屬性
    Teacher.prototype = new People();
    var jake = new Teacher("Jake",25,"JavaScript");
    var lucy = new Teacher("Lucy",24,"Swift");
    jake.teaching(); //教師Jake正在教授JavaScript課程。
    lucy.teaching(); //教師Lucy正在教授Swift課程。
```
3. 混合模式
屬性使用物件冒充方式繼承，方法使用原型鏈方式繼承
```JavaScript
    function People(name,age){
        this.age = age;
        this.name = name;
    }
    //方法都放入原型鏈中
    People.prototype = {
        constructor:People,
        sayHi:function(){
            console.log("Hello, I am"+this.name+","+this.age+"years old ")
        }
    }
    function Teacher(name,age,subject){
        //用物件冒充把屬性繼承過來
        People.call(this,name,age);
        this.subject = subject;
    }
    Teacher.prototype = new People();
    var jake = new Teacher("Jake",25,"JavaScript");
    var lucy = new Teacher("Lucy",24,"Swift");
    jake.teaching(); //教師Jake正在教授JavaScript課程。
    lucy.teaching(); //教師Lucy正在教授Swift課程。
```
# 建立物件
```JavaScript
    var teacher = {};
    console.log(typeof teacher); //object
```
```JavaScript
- teacher物件中有三個屬性 and 兩個方法
    var teacher = {
        name:"帥哥",
        age:25,
        subject:"JavaScript",
        teaching:function(){
            console.log("開始教學");
        },
        relaxing:function(){
            console.log("開始睡覺")
        }
    };
    teacher.teaching(); //開始教學
    teacher["relaxing"]();//開始睡覺
```
# 修改物件

```JavaScript
    teacher.subject = "PHP"; //將專業修改為PHP
    teacher.teaching = function(){
        console.log("教你彈吉他");
    };
    teacher.students = ["Amy","Benson","Cathlyn"]; //增加學員列表
```

# this

```JavaScript
    var person = {
        name:"Jake",
        sayHi:function(){
            console.log("Hi, My name is " + this.name);
        }
    };
    person.sayHi(); //Hi, My name is Jake
```
# 五種原始類型
1. Undefined
2. Null
3. Boolean
4. Number
5. String

## Boolean物件
- 以下為false
0,-0,null,false,NaN,undefined,""
```JavaScript
    console.log(new Boolean(0))//false
```
## Function物件
- toString方法是由teahcer物件呼叫的，toString方法中的this就代表目前teacher物件本身
```JavaScript
    var teacher = {
        name:"帥哥",
        age:"25",
        toString:function(){
            console.log("姓名:"+this.name+"、年齡:"+this.age)
        }
    }
    teacher.toString();//姓名:帥哥、年齡:25
```
- 建置函數中使用this，new關鍵字會建立一個空白物件，然後將建置函數中的this和這個物件綁定
- Function實例物件中提供以下幾種方法方法，這個方法可以接收兩個參數
1. apply()
- 呼叫方法的上下文，即函數中this關鍵字的指向
- 為一個陣列，陣列中的元素將被作為實際參數傳入函數
```JavaScript
    var student = {
        name:"Lucy",
        age:23
    }
    teacher.toString.apply(student, ["Student"]); //Student 姓名:Lucy、年齡:23
```
2. call()
- 同apply
- 參數個數不一定，第1個參數為要綁定到this的物件，之後所有參數都會作為實際參數傳入函數
```JavaScript
    var student = {
        name:"Lucy",
        age:23
    }
    teacher.toString.call(student,"Student"); //Student 姓名:Lucy、年齡:23
```
3. bind()
- 建立一個新的函數
- 第1個參數為新建立函數呼叫時的this指向
- 之後所有參數都作為預設內建實際參數傳入函數
```JavaScript
    var studentToString = teacher.toString.bind(student, "Student");
    studentToString(); //Student 姓名:Lucy、年齡:25
```

## Object物件
```JavaScript
    //使用字面常數語法建立物件
     var teacher = {
        name:"帥哥",
        age:"25",
        toString:function(){
            console.log("姓名:"+this.name+"、年齡:"+this.age)
        }
    }
    //使用Object建置函數建立物件
    var student = new Object();
    student.name = "帥哥";
    student.age = 24;
    student.learning = function(){
        console.log("learning...")
    }
```
## defineProperty()
- 直接在一個物件上定義一個新的屬性或修改一個已經存在的屬性
```JavaScript
    Object.defineProperty(student,"name",{
        configurable:true,
        enumerable:true,
        writable:true,
        value:"July"
    });
    console.log(student.name); //July
```
- defineProperty()中的getter() and setter()
```JavaScript
    var student = new Object();
    student.name = "帥哥";
    student.age = 24;
    student.learning = function(){
        console.log("learning...")
    }
    Object.defineProperty(student,"name",{
    configurable:true,
    enumerable:true,
    get:function(){
        console.log("正在使用name屬性");
        return name;
    }
    set:function(value){
        console.log("將要設定name屬性");
        name = value;
    }
    });
    console.log(student.name); //正在使用name屬性帥哥
    student.name = "July"; //將要設定name屬性
    console.log(student.name); //正在使用name屬性July
```
**描述參數中的value, writable與get, set不能同時存在**

## Object建置方法物件中的常用函數
- assing 淺拷貝
```JavaScript
    var teacher = {
        name:"Jake",
        age:24,
        teaching:function(){
            console.log("teaching");
        }
    };
    var teacher2 = {
        subject:"JavaScript"
    }
    Object.defineProperty(teacher,"number",{
        value:1001,
        enumberable:false
    });
    console.log(teahcer.number); //1001
    for(prop in teacher){
        console.log(prop);
    }
    //進行物件可列舉屬性的複製
    var obj = {};
    //第1個參數為目標物件，其後的參數為要被複製屬性的物件
    Object.assign(obj,teacher,teacher2);
    console.log(obj.name+obj.age+obj.subject);//Jake24JavaScript
    obj.teaching();//teaching
    console.log(obj.number); //undefined
```
- create() 建立物件 第1個參數為所建立物件的原型，第2個為要建立物件的屬性設定清單
```JavaScript
    //繼承的實現
    var base = {
        subject:"JavaScript";
    }
    var teacher1 = Object.create(base,{
        "name":{
            value:"Jake",
            enumerable:true
        },
        "age":{
            value:25,
            enumerable:true
        }
    })
    console.log(teacher1); //{name: "Jake", age: 25}
    console.log(teacher1.subject); //JavaScript
```
- freeze() 凍結物件使其不能增加修改或刪除物件的屬性
```JavaScript
    var fre = {
        name:"Jake"
    }
    fre = Object.freeze(fre);
    fre.name = "Lucy";
    console.log(fre); //{name:"Jake"}
```
- getOwnPropertyDescriptor() 取得物件某個屬性的設定資訊
- getPrototypeOf() 取得某個物件的原型物件
- seal() 密封物件 與freeze()的不同點在於可以修改
## 弱型別舉例
- num3在呼叫toString()方法的時候，JS把它當作物件處理，但並沒有真正將其轉為Number實例物件
```JavaScript
    var num3 = 100;
    console.log(typeof num3);//number
    var str = num3.toString();
    console.log(typeof str);//string
    console.log(typeof num3);//number
```

# 當使用New的時候

1. 建立一個空白物件建立原型鏈
2. 執行建置函數，將函數中的this關鍵字與新增的物件進行綁定
3. 將新增的物件傳回
- 以下為建立原始數值，並非**Number實例物件**
```JavaScript
    var num4 = Number(5);
    console.log(typeof num4);//number
```


